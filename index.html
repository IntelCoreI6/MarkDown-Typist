 <!DOCTYPE html>
 <html lang="en">
 <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown typer</title>
    <link href="style.css" rel="stylesheet"/> 
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel="stylesheet">
 </head>
 <body>
<div class="main-content">
<h1 class="title">MarkDown type test</h1>

<div id="splashphrase"></div>
<div id="typing-window" class="container"> Hey there you are an alstarr</div>
<div id="timer" class="container">00:00</div>
<div id="stats">
    <div id="wpm" class="mini-container">
    <div class="mini-container-title">WPM</div>
    <div id="WPM_VALUE" class="mini-container-value">00</div>
    </div>
    <div id="accuracy" class="mini-container">
    <div class="mini-container-title">ACCURACY</div>
    <div id="accuracy_value" class="mini-container-value">00</div>
    </div>    
    <div id="rating" class="mini-container">
    <div class="mini-container-title">WORDS</div>
    <div id="rating_VALUE" class="mini-container-value">00</div>
    </div>
    <input id="hiddenInput" type="text" style="opacity:0; position:absolute; left:-9999px;">
</div>
</div>
<script>
    const splashes = ["Type away each day to keep all the slowness away", "Obsidian is the best!"]
    const typing_window = document.getElementById("typing-window")
    const timerEl = document.getElementById("timer")
    // FIX: Corrected variable name from wpmel to wpmEl for consistency
    const wpmEl = document.getElementById("WPM_VALUE")
    const accEl = document.getElementById("accuracy_value")
    // Note: Your HTML ID for the words value is "rating_VALUE".
    const wordsEl = document.getElementById("rating_VALUE")
    let input = document.getElementById("hiddenInput")

    const typingText = [
  // Line 1
  [
    { word: "#", status: "pending" },
    { word: "Mastering", status: "pending" },
    { word: "Markdown:", status: "pending" },
    { word: "A", status: "pending" },
    { word: "True", status: "pending" },
    { word: "Test", status: "pending" }
  ],

  // Empty line
  [],

  // Line 3
  [
    { word: ">", status: "pending" },
    { word: "\"Typing", status: "pending" },
    { word: "isn't", status: "pending" },
    { word: "just", status: "pending" },
    { word: "a", status: "pending" },
    { word: "skill;", status: "pending" },
    { word: "it's", status: "pending" },
    { word: "an", status: "pending" },
    { word: "*art*.", status: "pending" },
    { word: "\"", status: "pending" },
    { word: "-", status: "pending" },
    { word: "Anonymous", status: "pending" }
  ],

  [],

  // Next paragraph
  [
    { word: "Welcome", status: "pending" },
    { word: "to", status: "pending" },
    { word: "the", status: "pending" },
    { word: "**Ultimate", status: "pending" },
    { word: "Markdown", status: "pending" },
    { word: "Typing", status: "pending" },
    { word: "Challenge**.", status: "pending" },
  ],
  [
    { word: "Below,", status: "pending" },
    { word: "you'll", status: "pending" },
    { word: "encounter", status: "pending" },
    { word: "a", status: "pending" },
    { word: "maze", status: "pending" },
    { word: "of", status: "pending" },
    { word: "symbols,", status: "pending" },
    { word: "syntax,", status: "pending" },
    { word: "and", status: "pending" },
    { word: "subtle", status: "pending" },
    { word: "spacing", status: "pending" },
    { word: "traps.", status: "pending" },
    { word: "Stay", status: "pending" },
    { word: "sharp:", status: "pending" }
  ],

  [],

  [
    { word: "-", status: "pending" },
    { word: "**Bold**,", status: "pending" },
    { word: "*italic*,", status: "pending" },
    { word: "and", status: "pending" },
    { word: "`inline", status: "pending" },
    { word: "code`", status:"pending"},
    { word: "must", status: "pending" },
    { word: "not", status: "pending" },
    { word: "confuse", status: "pending" },
    { word: "you.", status: "pending" }
  ],

  [
    { word: "-", status: "pending" },
    { word: "Create", status: "pending" },
    { word: "lists:", status: "pending" }
  ],

  [
    { word: "    -", status: "pending" },
    { word: "Nested", status: "pending" },
    { word: "lists", status: "pending" },
    { word: "(like", status: "pending" },
    { word: "this", status: "pending" },
    { word: "one).", status: "pending" }
  ],

  [
    { word: "    -", status: "pending" },
    { word: "And", status: "pending" },
    { word: "this", status: "pending" },
    { word: "one.", status: "pending" }
  ],

  [
    { word: "-", status: "pending" },
    { word: "Use", status: "pending" },
    { word: "[links](https://example.com)", status: "pending" },
    { word: "correctly.", status: "pending" }
  ],

  [
    { word: "-", status: "pending" },
    { word: "Quotes?", status: "pending" },
    { word: "Use", status: "pending" },
    { word: "`>`", status: "pending" },
    { word: "without", status: "pending" },
    { word: "missing", status: "pending" },
    { word: "the", status: "pending" },
    { word: "space.", status: "pending" }
  ],

  [
    { word: "-", status: "pending" },
    { word: "Escape", status: "pending" },
    { word: "characters:", status: "pending" },
    { word: "\\*not", status: "pending" },
    { word: "bold\\*,", status: "pending" },
    { word: "\\_not", status: "pending" },
    { word: "italic\\_,", status: "pending" },
    { word: "and", status: "pending" },
    { word: "\\\\backslashes\\\\.", status: "pending" }
  ],

  [
    { word: "-", status: "pending" },
    { word: "Code", status: "pending" },
    { word: "blocks:", status: "pending" }
  ],

  [
    { word: "```js", status: "pending" }
  ],

  [
    { word: "const", status: "pending" },
    { word: "trickyFunction", status: "pending" },
    { word: "=", status: "pending" },
    { word: "()","status": "pending" },
    { word: "=>", status: "pending" },
    { word: "{", status: "pending" }
  ],

  [
    { word: "return", status: "pending" },
    { word: "\"Mind", status: "pending" },
    { word: "your", status: "pending" },
    { word: "brackets!\";", status: "pending" }
  ],

  [
    { word: "};", status: "pending" }
  ],

  [
    { word: "```", status: "pending" }
  ],

  [
    { word: "-", status: "pending" },
    { word: "Don't", status: "pending" },
    { word: "ignore", status: "pending" },
    { word: "the", status: "pending" },
    { word: "`#`", status: "pending" },
    { word: "headers", status: "pending" },
    { word: "or", status: "pending" },
    { word: "miss", status: "pending" },
    { word: "a", status: "pending" },
    { word: "`---`", status: "pending" },
    { word: "separator.", status: "pending" }
  ],

  [],

  [
    { word: "**Final", status: "pending" },
    { word: "Warning**:", status: "pending" },
    { word: "Inconsistency", status: "pending" },
    { word: "is", status: "pending" },
    { word: "your", status: "pending" },
    { word: "worst", status: "pending" },
    { word: "enemy.", status: "pending" },
    { word: "Happy", status: "pending" },
    { word: "typing!", status: "pending" }
  ]
];
    
    let currentLine = 0;
    let currentWord = 0;
    let currentLetter = 0;

    let startTime = null
    let timerInterval = null;
    let correctChars = 0;
    let errorCount = 0;
    let completedWords = 0;


    function startTimer(){
        if (startTime) return;
        startTime = new Date();
        timerInterval = setInterval(() => {
            const elapsedTime = Math.floor((new Date() - startTime)/1000)
            const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
            const seconds = (elapsedTime % 60).toString().padStart(2, '0');
            timerEl.textContent = `${minutes}:${seconds}`;

            const timeInMinutes = elapsedTime / 60;
            if (timeInMinutes > 0) {
                const grossWPM = (correctChars / 5) / timeInMinutes;
                wpmEl.textContent = Math.round(grossWPM).toString().padStart(2, '0');
            }
            const totalTyped = correctChars + errorCount;
            if (totalTyped > 0) {
                const accuracy = (correctChars / totalTyped) * 100;
                accEl.textContent = Math.round(accuracy).toString().padStart(2, '0');
            }
        }, 1000);
    }

    
    function renderText() {
        typing_window.innerHTML = "";
        for (let lineIdx = 0; lineIdx < typingText.length; lineIdx++) {
            const line = typingText[lineIdx];
            if (line.length === 0) {
                typing_window.innerHTML += "<br>";
                continue;
            }
            let lineHTML = "";
            for (let wordIdx = 0; wordIdx < line.length; wordIdx++) {
                // Render the word itself
                const wordToFormat = line[wordIdx].word.replace(/ /g, '&nbsp;');
                lineHTML += formatWord(
                    wordToFormat,
                    line[wordIdx].word,
                    wordIdx,
                    lineIdx,
                    currentWord,
                    currentLine,
                    currentLetter
                );

                // If not the last word, render the space after it
                if (wordIdx < line.length - 1) {
                    let spaceClass = "letter";
                    // Check if the cursor should be on this space
                    if (lineIdx === currentLine && wordIdx === currentWord && currentLetter === line[wordIdx].word.length) {
                        spaceClass += " current-letter";
                    }
                    // Use &nbsp; to ensure the space is rendered and can be styled
                    lineHTML += `<span class="${spaceClass}">&nbsp;</span>`;
                }
            }
            typing_window.innerHTML += `<div>${lineHTML}</div>`;
        }
        const cursor = typing_window.querySelector(".current-letter");
        if (cursor) {
            cursor.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest'})
        }
    }

    function formatWord(originalWord, wordIdx, lineIdx, currentWord, currentLine, currentLetter){
        let letters = originalWord.split('').map((char, i) => {
            let classes = "letter";
            if (lineIdx === currentLine && wordIdx === currentWord) {
                if (i < currentLetter) {
                    classes += " correct";
                } else if (i === currentLetter) {
                    classes += " current-letter";
                }
            }
            // Replace space characters with a non-breaking space for rendering.
            const displayChar = (char === ' ') ? '&nbsp;' : char;
            return `<span class="${classes}">${displayChar}</span>`;
        }).join('');

        let wordClass = "word";
        if (lineIdx < currentLine || (lineIdx === currentLine && wordIdx < currentWord)) {
            wordClass += " correct";
        } else {
            wordClass += " pending";
        }
        return `<span class="${wordClass}">${letters}</span>`;
    }


    renderText()

    input.addEventListener('keydown', (e) => {
        e.preventDefault();
        startTimer();

        // Use e.key for layout-aware character input
        const key = e.key;

        // Get current word and check if we're at the space after it
        const wordObj = typingText[currentLine]?.[currentWord];
        
        if (!wordObj) {
            if(timerInterval) clearInterval(timerInterval);
            return;
        }
        const isAtEndOfWord = currentLetter === wordObj.word.length;

        // Clear previous error animations
        document.querySelector('.main-content').classList.remove('error-shake');
        const errorLetter = document.querySelector('.current-letter.error');
        if (errorLetter) errorLetter.classList.remove('error');

        if (key === 'Enter') {
            // FIX: Correctly find the next non-empty line without double-incrementing
            currentLine++;
            while (currentLine < typingText.length && typingText[currentLine].length === 0) {
                currentLine++;
            }
            currentWord = 0;
            currentLetter = 0;
        } else if (key === ' ' && isAtEndOfWord) {
            // Correct space press
            correctChars++;
            completedWords++;
            const wordsEl = document.getElementById("rating_value");

            if(wordsEl) wordsEl.textContent = completedWords.toString().padStart(2, '0');

            if (currentWord < typingText[currentLine].length - 1) {
                currentWord++;
            } else {
                currentLine++;
                while (typingText[currentLine]?.length === 0) currentLine++;
                currentWord = 0;
            }
            currentLetter = 0;
        } else if (key.length === 1 && !isAtEndOfWord && key === wordObj.word[currentLetter]) {
            // Correct character press
            correctChars++;
            currentLetter++;
        } else if (key.length === 1) {
            // Any other character press is an error
            errorCount++;
            document.querySelector('.main-content').classList.add('error-shake');
            const current = document.querySelector('.current-letter');
            if (current) current.classList.add('error');
        }
        renderText();
    });
    window.onload = () => {
        input.focus();
    }
    window.addEventListener('click', () => input.focus());

    
</script>
 </body>
 </html>